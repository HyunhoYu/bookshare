# BookShare 프로젝트 컨텍스트

## 프로젝트 개요
공유서점 REST API - 시민이 책장을 임대하여 본인 책을 판매하는 플랫폼
- Spring Boot 3.2.0 / Java 17 / Maven
- MyBatis + Oracle DB (21c XE)
- JWT 인증 + AOP 기반 역할 체크 (@RequireRole)

## DB 접속 정보
```
DB_URL=jdbc:oracle:thin:@127.0.0.1:1521:XE
DB_USERNAME=system
DB_PASSWORD=Paperplane!23
JWT_SECRET=thisissecretkey991209bookshare1234567890
```

### Admin 계정
- email: `admin@bookshare.com` / password: `admin1234`

### sqlplus 접근 방법 (WSL 환경)
```bash
# NLS_LANG 필수 (없으면 비밀번호 인코딩 불일치로 ORA-01017 발생)
# set NLS_LANG=...&& 사이에 공백 없이 붙여야 함
cmd.exe /c "set NLS_LANG=AMERICAN_AMERICA.AL32UTF8&& sqlplus -S system/\"Paperplane!23\"@127.0.0.1:1521/XE @C:\Users\tit\파일명.sql"
```
- **주의**: SQL 파일은 반드시 Windows 경로(`C:\Users\tit\`)에 위치해야 함. `/tmp/` 등 Linux 경로는 sqlplus에서 접근 불가
- **주의**: sqlplus SQL 파일에 한글 주석 넣으면 인코딩 깨져서 INSERT/UPDATE 실패함. 한글 데이터는 UNISTR 사용하거나 주석은 영문으로.
- **주의**: UNISTR도 CASE WHEN 비교 시 ORA-12704 (character set mismatch) 발생 가능. 한글 컬럼 값 비교가 필요하면 Java 레벨에서 처리 권장.

## 프로젝트 구조
```
src/main/java/my/
├── api/              # REST Controller (12개)
├── domain/           # Service(interface+impl) + Mapper + VO + DTO
├── annotation/       # @RequireRole, @ValidSettlementRatio
├── aop/              # RoleCheckAspect
├── common/           # ApiResponse, ErrorCode, 예외 클래스, BankCodeResolver
├── enums/            # Role(ADMIN,BOOK_OWNER,CUSTOMER,EMPLOYEE), BookState
├── filter/           # JwtFilter
├── jwt/              # JwtProvider
└── validator/
src/main/resources/mybatis/mapper/  # MyBatis XML (12개)
```

## Identity 시퀀스 매핑 (INSERT 시 필수)
프로젝트는 selectKey + CURRVAL 패턴을 사용한다. useGeneratedKeys 사용하지 않음.
```
USERS                    → ISEQ$$_78221
BOOK_CASE_TYPE           → ISEQ$$_78216
BOOK_CASE                → ISEQ$$_78225
BOOK_CASE_OCCUPIED_RECORD → ISEQ$$_78234
BOOK                     → ISEQ$$_78230
BOOK_OWNER_SETTLEMENT    → ISEQ$$_78238
BOOK_SALE_RECORD         → ISEQ$$_78242  (GENERATED BY DEFAULT - ID를 명시적으로 넘김)
SETTLEMENT_RATIO         → ISEQ$$_77702
RENTAL_SETTLEMENT        → ISEQ$$_78284
SETTLEMENT_RENTAL_OFFSET → ISEQ$$_78788
```

### INSERT 매퍼 작성 패턴
```xml
<insert id="insert" parameterType="...VO">
    <selectKey keyProperty="id" resultType="long" order="AFTER">
        SELECT "ISEQ$$_XXXXX".CURRVAL FROM DUAL
    </selectKey>
    INSERT INTO 테이블 (컬럼들) VALUES (값들)
</insert>
```
- BOOK_SALE_RECORD만 예외: BOOK.ID를 그대로 사용 (1:1 관계) → ID를 명시적으로 INSERT

## 비즈니스 정책

### 정산 정책 (변경됨)
- ~~구 정책: 책 판매 시 Settlement 생성 (settledAt=NULL) → 정산 시 settledAt 업데이트~~
- **신 정책: 정산 실행(POST /settlements) 시에만 Settlement 생성 (settledAt 즉시 설정)**
- 미정산 = BOOK_SALE_RECORD에서 BOOK_OWNER_SETTLEMENT_ID IS NULL인 레코드
- 정산 완료 = BOOK_OWNER_SETTLEMENT에 레코드 존재 (항상 settledAt이 있음)

### 정산 시 임대료 상계 정책 (구현 완료)
- **배경**: 토스 지급대행 API는 월 고정 이용료 + 건당 수수료가 부과됨. 송금 횟수를 줄여야 비용 절감
- **정책**: 책 판매 정산 실행 시 해당 책소유주의 미납 임대료(RENTAL_SETTLEMENT.STATUS='UNPAID', REMAINING_AMOUNT > 0)를 FIFO로 공제한 후 차액만 송금
- **공제 한도**: 정산금(ownerAmount) 한도까지만 공제. 초과분은 UNPAID 유지
- **공제 순서**: FIFO (오래된 미납 임대료부터, TARGET_MONTH ASC)
- **부분 공제**: 임대료 50,000원 중 30,000원만 공제 가능 → remainingAmount=20,000, UNPAID 유지
- **송금 스킵**: actualPayoutAmount가 0이면 토스 송금 API 호출하지 않음 (payoutKey="RENTAL_OFFSET", transferStatus="OFFSET_COMPLETED")
- **상계 이력**: SETTLEMENT_RENTAL_OFFSET 테이블에 N:N 상계 내역 기록
- **예시**: 판매 정산금 80,000원 - 미납 임대료 50,000원(FIFO 1건) = 실제 송금 30,000원

### 배치 정산 (구현 완료)
- **수동**: Admin이 `POST /api/settlements/batch` 호출 → 미정산 판매기록이 있는 전체 BookOwner 일괄 정산
- **자동**: `SettlementScheduler` - 매월 1일 06:00 `@Scheduled(cron)` 실행
- **실패 처리**: 개별 BookOwner 정산 실패 시 건너뛰고 다음 진행 (로그 경고)
- **`@EnableScheduling`**: BookshareApplication에 적용됨

### 정산 실행 검증 순서 + 송금 흐름
1. saleRecordIds 비어있는지
2. 책소유주 존재 여부
3. 계좌 정보 등록 여부
4. saleRecordIds가 모두 해당 bookOwner 소유인지 (BOOK JOIN)
5. 이미 정산된 기록이 아닌지
6. 금액 계산 (sumAmountsByIds: 판매 시점 비율로 ownerAmount 산출)
7. **상계 계산**: 미납 임대료 FIFO 조회 → 공제 금액 계산 → actualPayoutAmount 산출
8. 토스페이먼츠 송금 (actualPayoutAmount > 0일 때만, TossPaymentService.transfer())
9. BOOK_OWNER_SETTLEMENT INSERT (금액 + deductedRentalAmount + actualPayoutAmount + payoutKey + transferStatus 포함) → sale_record들의 settlement_id UPDATE
10. **SETTLEMENT_RENTAL_OFFSET INSERT** + **RENTAL_SETTLEMENT UPDATE** (deductedAmount, remainingAmount, status)

### 토스페이먼츠 연동
- `TossPaymentService.transfer(bankCode, accountNumber, amount, holderName)` → `TossTransferResponseDto`
- 구현체: `TossPaymentServiceImpl` (RestTemplate + Basic Auth)
- 설정값: `toss.payments.secret-key`, `toss.payments.base-url` (application.yml / .env)
- 송금 실패 시 `SETTLEMENT_TRANSFER_FAIL` 예외 → @Transactional 롤백
- `BankCodeResolver`: 은행명 → 2자리 코드 변환 유틸리티 (bankCode가 null일 때 폴백)
- bankName은 BankCodeResolver에 등록된 한글 은행명만 유효 (국민은행, 신한은행, 하나은행 등). 미등록 은행명이면 `BANK_CODE_NOT_FOUND` 예외 발생

#### 토스 지급대행 API 현황 (MVP 단계)
- **현재**: `TossPaymentServiceImpl`은 `/v1/payouts` 호출하는 단순 구현. 실제 토스 지급대행은 V2 API(`/v2/payouts`)로 별도 계약 + JWE 암호화 + 셀러 등록이 필요하여 현재 사용 불가
- **테스트**: `TestTossPaymentService`(@Primary)가 Mock 응답 반환 → JUnit은 항상 Mock 사용
- **MVP 전략**: 정산 실행 시 금액 계산/검증/DB 기록까지만 처리하고, 실제 송금은 관리자가 수동 이체. 사업 확장 시 토스 지급대행 계약(사업자등록 + 연 11만원) 후 실제 구현체 교체
- **토스 지급대행 실제 연동 시 필요사항**: V2 API 엔드포인트, 보안 키(64자 hex)로 JWE 암호화, `TossPayments-api-security-mode: ENCRYPTION` 헤더, 셀러 등록 → 잔액 확인 → 지급 요청 3단계 흐름
- **.env에 `TOSS_SECRET_KEY` 설정 완료** (test_sk_ 테스트 키). 단, 지급대행 계약 없이는 401 반환됨

#### Spring Profile 기반 Mock/실제 구현체 분리
- **문제**: 사업자등록 + 토스 지급대행 계약 없이는 실제 송금 API 테스트 불가 (401 반환)
- **해결**: Spring Profile을 활용하여 dev/prod 환경별 구현체 자동 전환
- **구조**:
  - `TossPaymentService` (인터페이스) — 송금 계약 정의
  - `TossPaymentServiceImpl` (`@Profile("!dev")`) — 실제 토스 API 호출 (prod 환경)
  - `MockTossPaymentService` (`@Profile("dev")`, `@Primary`) — 가짜 성공 응답 반환 (dev 환경)
  - `TestTossPaymentService` (src/test, `@Primary`) — JUnit 전용 Mock
- **환경 전환**: `application.yml`의 `spring.profiles.active` 값만 변경
  - `dev` → Mock 사용 (개발/시연용, 송금 없이 정산 흐름 전체 동작)
  - `prod` (또는 미지정) → 실제 토스 API 호출
- **전환 시나리오**: 사업자등록 + 토스 계약 완료 후 `dev` → `prod`로 변경하면 실제 송금 활성화

### COMMON_CODE 참조 무결성 (복합 FK + 앱 레벨 검증)
COMMON_CODE 테이블은 복합 PK (GROUP_CODE, CODE). 3개 테이블이 참조:

| 테이블 | GROUP_CODE_ID (DEFAULT) | COMMON_CODE_ID | FK 이름 | 앱 레벨 검증 |
|---|---|---|---|---|
| BOOK_CASE | 'LOCATION' | 위치 코드 (01, 02, 03) | FK_BC_COMMON_CODE | validateLocationCode() |
| BOOK | 'BOOK_TYPE' | 책 분류 코드 | FK_BOOK_COMMON_CODE | validateBookTypeCode() |
| BOOK_SALE_RECORD | 'BUY_TYPE' | 구매 유형 코드 (01~05) | FK_BSR_COMMON_CODE | selectByGroupCodeAndCode() |

- 각 테이블에 `GROUP_CODE_ID` 컬럼 (VARCHAR2, NOT NULL, DEFAULT 설정)
- 복합 FK: `(GROUP_CODE_ID, COMMON_CODE_ID)` → `COMMON_CODE (GROUP_CODE, CODE)`
- INSERT 시 서비스 코드에서 `setGroupCodeId("LOCATION"/"BOOK_TYPE"/"BUY_TYPE")` 명시 필수
- CommonCode 조회 API: `GET /api/common-codes?groupCode=LOCATION` (CommonCodeController)

### COMMON_CODE 데이터
```
GROUP_CODE  | CODE | CODE_NAME
LOCATION    | 01   | 1층 A구역
LOCATION    | 02   | 1층 B구역
LOCATION    | 03   | 2층 A구역
BOOK_TYPE   | 01~10| 소설, 역사, 스포츠, 과학, 자기계발, 경제/경영, 에세이, 만화, 외국문학, 기타
BUY_TYPE    | 01~05| 신용카드, 현금, 체크카드, 계좌이체, 간편결제
```

### 조건부 Unique Index 패턴
Oracle의 "NULL은 인덱스에서 제외" 특성을 이용한 패턴:
```sql
CREATE UNIQUE INDEX 인덱스명 ON 테이블 (
    CASE WHEN 조건컬럼 IS NULL THEN 유니크대상컬럼 END
);
```
적용 현황:
- USERS.EMAIL: DELETED_AT IS NULL인 행만 UNIQUE (소프트 삭제된 이메일 재사용 가능)
- BOOK_CASE_OCCUPIED_RECORD: UN_OCCUPIED_AT IS NULL인 행만 BOOK_CASE_ID UNIQUE (책장당 활성 점유 1건 제한)
- BOOK_CASE_TYPE.CODE: UNIQUE 제약조건 (UQ_BOOK_CASE_TYPE_CODE) — 동일 코드 중복 생성 불가

### 소프트 삭제
- USERS 테이블의 DELETED_AT 컬럼 사용 (NULL이면 활성)
- BOOK 테이블의 DELETED_AT 컬럼 사용 (회수 완료 시 SYSTIMESTAMP 세팅)

### 임대료 정산 정책
- BOOK_CASE_OCCUPIED_RECORD에 `EXPIRATION_DATE`(만기일자), `DEPOSIT`(보증금, 월 임대료와 동일 금액) 컬럼 추가
- 점유(occupy) 생성 시 만기일자까지 월별 RENTAL_SETTLEMENT 레코드를 일괄 생성 (선불 청구서 패턴)
- RENTAL_SETTLEMENT는 책소유주별 + 월별로 생성되며, 금액과 정산 상태를 관리
- 임대료 납부 기한: 매월 말일

#### DEPOSIT 자동 초기화
- DEPOSIT 값은 클라이언트 입력 없이 자동 초기화
- 초기화 경로: `BOOK_CASE → BOOK_CASE_TYPE.MONTHLY_PRICE`
- occupy 시 해당 책장의 BookCaseType을 조회하여 monthlyPrice를 deposit으로 세팅

#### 입거 시 결제 (일할 계산)
- 입거 시 **보증금 + 입거월 잔여일 일할 임대료**를 납부해야 점유 시작
- 일할 계산 공식: `월 임대료 / 해당 월 총 일수 × 남은 일수` (원 미만 절사)
- 예시: 월 임대료 50,000원, 2월(28일) 15일 입거 → 50,000 / 28 × 14 = 25,000원 + 보증금 50,000원
- 입거월의 RENTAL_SETTLEMENT 레코드는 일할 계산된 금액으로 생성
- 이후 월(다음 달 1일~)부터는 정상 월 임대료로 생성

#### BOOK_CASE_OCCUPIED_RECORD 추가 컬럼
| 컬럼 | 타입 | 설명 |
|---|---|---|
| EXPIRATION_DATE | DATE NOT NULL | 만기일자 |
| DEPOSIT | NUMBER NOT NULL | 보증금 (= 월 임대료) |
| DEPOSIT_STATUS | VARCHAR2(20) DEFAULT 'HELD' | HELD(보관중) / RETURNED(반환) / OFFSET(미납차감) |

#### RENTAL_SETTLEMENT 테이블
| 컬럼 | 타입 | 설명 |
|---|---|---|
| ID | NUMBER (IDENTITY) | PK |
| OCCUPIED_RECORD_ID | NUMBER (FK) | BOOK_CASE_OCCUPIED_RECORD.ID 참조 |
| BOOK_OWNER_ID | NUMBER (FK) | 책소유주 ID |
| TARGET_MONTH | VARCHAR2(7) | 대상 월 ('YYYY-MM') |
| AMOUNT | NUMBER | 월 임대료 (생성 시점 MONTHLY_PRICE 고정) |
| STATUS | VARCHAR2(20) DEFAULT 'UNPAID' | UNPAID / PAID / CANCELLED |
| DEDUCTED_AMOUNT | NUMBER DEFAULT 0 | 상계로 공제된 누적 금액 |
| REMAINING_AMOUNT | NUMBER | 남은 임대료 (= AMOUNT - DEDUCTED_AMOUNT) |
| PAID_AT | TIMESTAMP | 결제 확인 시각 |
| CREATED_AT | TIMESTAMP DEFAULT SYSTIMESTAMP | 생성 시각 |

- 제약조건: `UNIQUE (OCCUPIED_RECORD_ID, TARGET_MONTH)` — 동일 점유 + 동일 월 중복 방지
- 제약조건: `CHECK (STATUS IN ('UNPAID', 'PAID', 'CANCELLED'))`

#### SETTLEMENT_RENTAL_OFFSET 테이블 (정산-임대료 상계 내역)
| 컬럼 | 타입 | 설명 |
|---|---|---|
| ID | NUMBER (IDENTITY) | PK (ISEQ$$_78788) |
| SETTLEMENT_ID | NUMBER (FK) | BOOK_OWNER_SETTLEMENT.ID 참조 |
| RENTAL_SETTLEMENT_ID | NUMBER (FK) | RENTAL_SETTLEMENT.ID 참조 |
| OFFSET_AMOUNT | NUMBER | 이 건에서 공제한 금액 |
| CREATED_AT | TIMESTAMP DEFAULT SYSTIMESTAMP | 생성 시각 |

- N:N 관계: 하나의 정산이 여러 임대료를 공제, 하나의 임대료가 여러 정산에 걸쳐 부분 공제 가능

#### 조기 퇴거 정책
- 조기 퇴거는 언제든 가능
- 퇴거 시 UNPAID 상태인 임대료를 모두 납부해야 퇴거 처리 완료
- 납부 완료 후 unOccupyProcess 실행

#### 임대료 자동 납부 처리 (추후 구현 예정)
- **방식**: PG사 온라인 결제 (토스페이먼츠) + Webhook 자동 처리
- **흐름**: 프론트 결제 버튼 클릭 → 토스 결제창 → 결제 완료 → PG사 Webhook(`POST /api/webhooks/toss`) → 서버에서 자동으로 `RENTAL_SETTLEMENT.STATUS → PAID` 처리
- **기반**: 이미 `TossPaymentService`가 존재하므로 확장 가능
- **현재(MVP)**: 관리자가 입금 확인 후 수동 납부 처리 (`POST /api/rental-settlements/{id}/pay`)
- **전환 시 필요사항**: 토스페이먼츠 결제 위젯 프론트 연동, Webhook 수신 엔드포인트 구현, 결제 검증 로직

#### 연체 알림 (추후 고려)
- 임대료 연체 시 점주(ADMIN)와 책소유주(BOOK_OWNER) 양쪽에 알람/문자 발송 예정
- 구현 시기 미정 (알림 인프라 구축 후)

#### 계약 연장 정책
- 연장은 언제든 가능
- 연장 시 OR의 EXPIRATION_DATE를 새로운 만기일로 UPDATE
- 기존 만기일 이후 ~ 새 만기일까지 추가 RENTAL_SETTLEMENT 레코드 일괄 생성

### Book 상태 전이
```
NORMAL → SOLD (판매 시)
NORMAL → SHOULD_BE_RETRIEVED (임대 종료 시)
SHOULD_BE_RETRIEVED → soft delete (회수 시, DELETED_AT = SYSTIMESTAMP)
```

## 개발 진행 상황

### 기능 구현: 전부 완료
- Phase 1~3: 정산비율 설정, 책장 타입/등록, BookOwner 등록, 점유, 책 등록, 판매
- Phase 4: 미정산 조회, 정산 실행
- Phase 5: 책장 임대 종료, 회수 대기 목록, 책 회수
- Phase 6: 조회 API
- Phase 7: 토스페이먼츠 송금 연동 (settle() 시 실제 송금)

### 코드 품질 개선: 완료
- DTO 유효성 검증 (@Valid + Jakarta Validation 어노테이션)
- 권한 체크 (@RequireRole) 전 컨트롤러 적용
- soft delete 조건 (DELETED_AT IS NULL) 쿼리 보완
- @Transactional 쓰기 메서드 전체 적용
- GlobalExceptionHandler: DataIntegrityViolationException 처리 추가
- 중복 검증 (email, phone, residentNumber) UserAuthServiceImpl.save()에 중앙화
- COMMON_CODE 참조 무결성: 복합 FK (DB) + 앱 레벨 검증 (3개 테이블)
- BookCaseCreateDto: locationName → locationCode 리팩토링 (코드 직접 전달 방식)
- BookRegisterDto: bookType → bookTypeCode 리팩토링 (코드 직접 전달 방식)
- CommonCode 조회 API 추가 (GET /api/common-codes?groupCode=)

## 테스트 실행 방법
WSL 환경에서 Windows의 Maven을 통해 테스트 실행:
```bash
cd "/mnt/c/Users/tit/OneDrive/바탕 화면/bookshare" && cmd.exe /c "C:\Users\tit\run_test.cmd" 2>&1 | tail -10
```
- `run_test.cmd`는 `C:\Users\tit\` 에 위치
- 결과 마지막 10줄만 보면 `Tests run: 140, Failures: 0` 형태로 요약됨
- 실패 시 `| tail -10` 대신 `| grep -E "Tests run:|FAIL|ERROR.*Test" | head -30` 으로 실패 테스트 확인
- 현재 전체 테스트 수: **148개**

## 테스트 작성 패턴
```java
@SpringBootTest
@Transactional  // 테스트 후 자동 롤백
class XxxTest {
    // @Autowired로 실제 서비스 주입 (통합 테스트)
    // uniqueCode() → UUID.randomUUID().toString().substring(0,8) 로 유니크 데이터 생성
    // @DisplayName 한글로 작성
    // AssertJ 사용 (assertThat, assertThatThrownBy)
}
```
- 테스트 데이터 생성 순서: 정산비율 설정 → 책장타입 → 책장 → BookOwner(계좌포함) → 점유 → 책등록 → 판매
- 테스트 위치: `src/test/java/my/domain/{도메인}/`
- **중복 방지 필수**: phone, email, residentNumber, BookCaseType code는 반드시 `uniqueCode()` 기반 유니크 값 사용 (중복 검증 로직 때문)
- **bankName**: 테스트에서 bankName은 `"국민은행"` 등 BankCodeResolver에 등록된 유효한 한글 은행명 사용 (`"KB"` 등 약어 사용 금지)
- **locationCode**: 책장 생성 시 `setLocationCode("01")` 사용 (COMMON_CODE LOCATION 그룹의 CODE 값). `"1층 A구역"` 등 이름이 아닌 코드 직접 전달
- **bookTypeCode**: 책 등록 시 `setBookTypeCode("04")` 사용 (COMMON_CODE BOOK_TYPE 그룹의 CODE 값). `"과학"` 등 이름이 아닌 코드 직접 전달
- **buyTypeCommonCode**: 판매 기록 생성 시 `setBuyTypeCommonCode("01")` 사용 (COMMON_CODE BUY_TYPE 그룹의 CODE 값)
- soft delete 검증 시: `bookMapper.selectByIdIncludeDeleted(id)` 사용 (selectById는 DELETED_AT IS NULL 조건 포함)

## DTO / VO 패턴 규칙
- **VO**: DB 매핑 객체 (MyBatis resultMap). API 응답으로도 사용
- **DTO**: API 요청 전용. 유효성 검증 어노테이션은 DTO에만 부여
- **Controller**: 요청은 DTO로 받고, 서비스에 전달. 응답은 VO 반환
- **민감 필드**: UserVO의 `password`, `residentNumber`에 `@JsonIgnore` 적용 (API 응답에서 제외)
- VO를 `@RequestBody`로 직접 받지 않는다 (반드시 DTO 사용)

## 주요 참고 문서
- `BOOKSHARE_개발순서_및_서비스플로우.md` - 서비스 플로우 및 체크 로직

[//]: # (- `API_명세서_v2.html` - API 스펙)

[//]: # (- `erd.pdf` - ERD)

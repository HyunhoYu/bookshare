# BookShare 프로젝트 컨텍스트

## 프로젝트 개요
공유서점 REST API - 시민이 책장을 임대하여 본인 책을 판매하는 플랫폼
- Spring Boot 3.2.0 / Java 17 / Maven
- MyBatis + Oracle DB (21c XE)
- JWT 인증 + AOP 기반 역할 체크 (@RequireRole)

## DB 접속 정보
```
DB_URL=jdbc:oracle:thin:@127.0.0.1:1521:XE
DB_USERNAME=system
DB_PASSWORD=Paperplane!23
JWT_SECRET=thisissecretkey991209bookshare1234567890
```

### sqlplus 접근 방법 (WSL 환경)
```bash
# 비밀번호에 !가 있으므로 반드시 이스케이프
cmd.exe /c "sqlplus -S system/\"Paperplane!23\"@127.0.0.1:1521/XE @C:\Users\tit\파일명.sql"
```
- **주의**: sqlplus SQL 파일에 한글 주석 넣으면 인코딩 깨져서 INSERT/UPDATE 실패함. 한글 데이터는 UNISTR 사용하거나 주석은 영문으로.

## 프로젝트 구조
```
src/main/java/my/
├── api/              # REST Controller (11개)
├── domain/           # Service(interface+impl) + Mapper + VO + DTO
├── annotation/       # @RequireRole, @ValidSettlementRatio
├── aop/              # RoleCheckAspect
├── common/           # ApiResponse, ErrorCode, 예외 클래스들
├── enums/            # Role(ADMIN,BOOK_OWNER,CUSTOMER,EMPLOYEE), BookState
├── filter/           # JwtFilter
├── jwt/              # JwtProvider
└── validator/
src/main/resources/mybatis/mapper/  # MyBatis XML (12개)
```

## Identity 시퀀스 매핑 (INSERT 시 필수)
프로젝트는 selectKey + CURRVAL 패턴을 사용한다. useGeneratedKeys 사용하지 않음.
```
USERS                    → ISEQ$$_78221
BOOK_CASE_TYPE           → ISEQ$$_78216
BOOK_CASE                → ISEQ$$_78225
BOOK_CASE_OCCUPIED_RECORD → ISEQ$$_78234
BOOK                     → ISEQ$$_78230
BOOK_OWNER_SETTLEMENT    → ISEQ$$_78238
BOOK_SALE_RECORD         → ISEQ$$_78242  (GENERATED BY DEFAULT - ID를 명시적으로 넘김)
SETTLEMENT_RATIO         → ISEQ$$_77702
```

### INSERT 매퍼 작성 패턴
```xml
<insert id="insert" parameterType="...VO">
    <selectKey keyProperty="id" resultType="long" order="AFTER">
        SELECT "ISEQ$$_XXXXX".CURRVAL FROM DUAL
    </selectKey>
    INSERT INTO 테이블 (컬럼들) VALUES (값들)
</insert>
```
- BOOK_SALE_RECORD만 예외: BOOK.ID를 그대로 사용 (1:1 관계) → ID를 명시적으로 INSERT

## 비즈니스 정책

### 정산 정책 (변경됨)
- ~~구 정책: 책 판매 시 Settlement 생성 (settledAt=NULL) → 정산 시 settledAt 업데이트~~
- **신 정책: 정산 실행(POST /settlements) 시에만 Settlement 생성 (settledAt 즉시 설정)**
- 미정산 = BOOK_SALE_RECORD에서 BOOK_OWNER_SETTLEMENT_ID IS NULL인 레코드
- 정산 완료 = BOOK_OWNER_SETTLEMENT에 레코드 존재 (항상 settledAt이 있음)

### 정산 실행 검증 순서
1. saleRecordIds 비어있는지
2. 책소유주 존재 여부
3. 계좌 정보 등록 여부
4. saleRecordIds가 모두 해당 bookOwner 소유인지 (BOOK JOIN)
5. 이미 정산된 기록이 아닌지
6. BOOK_OWNER_SETTLEMENT INSERT → sale_record들의 settlement_id UPDATE

### 소프트 삭제
- USERS 테이블의 DELETED_AT 컬럼 사용 (NULL이면 활성)
- USERS.EMAIL에 조건부 UNIQUE 인덱스 적용됨 (DELETED_AT IS NULL인 행만)

### Book 상태 전이
```
NORMAL → SOLD (판매 시)
NORMAL → SHOULD_BE_RETRIEVED (임대 종료 시)
```

## 개발 진행 상황

### Phase 1~3: 구현 완료
순서 1~7 (정산비율 설정, 책장 타입/등록, BookOwner 등록, 점유, 책 등록, 판매)

### Phase 4: 진행 중
- 순서 8: GET /settlements/pending (Admin 전체 미정산) - 구현 완료
- 순서 9: GET /book-owners/{id}/settlements/pending (BookOwner별 미정산) - 구현 완료
- 순서 10: POST /settlements (정산 실행) - 코드 작성 완료, 테스트 검증 중

### Phase 5: 미구현
- 순서 11~14 (책장 임대 종료, 회수 대기 목록, 책 회수)

### Phase 6: 조회 API 전부 구현 완료

## 테스트 작성 패턴~~~~
```java
@SpringBootTest
@Transactional  // 테스트 후 자동 롤백
class XxxTest {
    // @Autowired로 실제 서비스 주입 (통합 테스트)
    // uniqueCode() → UUID.randomUUID().toString().substring(0,8) 로 유니크 데이터 생성
    // @DisplayName 한글로 작성
    // AssertJ 사용 (assertThat, assertThatThrownBy)
}
```
- 테스트 데이터 생성: 정산비율 설정 → 책장타입 → 책장 → BookOwner(계좌포함) → 점유 → 책등록 → 판매 순서 필수
- 테스트 위치: src/test/java/my/domain/{도메인}/

## 주요 참고 문서
- `BOOKSHARE_개발순서_및_서비스플로우.md` - 서비스 플로우 및 체크 로직

[//]: # (- `API_명세서_v2.html` - API 스펙)

[//]: # (- `erd.pdf` - ERD)

# BookShare 프로젝트 컨텍스트

## 프로젝트 개요
공유서점 REST API - 시민이 책장을 임대하여 본인 책을 판매하는 플랫폼
- Spring Boot 3.2.0 / Java 17 / Maven
- MyBatis + Oracle DB (21c XE)
- JWT 인증 + AOP 기반 역할 체크 (@RequireRole)

## DB 접속 정보
```
DB_URL=jdbc:oracle:thin:@127.0.0.1:1521:XE
DB_USERNAME=system
DB_PASSWORD=Paperplane!23
JWT_SECRET=thisissecretkey991209bookshare1234567890
```

### Admin 계정
- email: `admin@bookshare.com` / password: `admin1234`

### sqlplus 접근 방법 (WSL 환경)
```bash
# NLS_LANG 필수 (없으면 비밀번호 인코딩 불일치로 ORA-01017 발생)
# set NLS_LANG=...&& 사이에 공백 없이 붙여야 함
cmd.exe /c "set NLS_LANG=AMERICAN_AMERICA.AL32UTF8&& sqlplus -S system/\"Paperplane!23\"@127.0.0.1:1521/XE @C:\Users\tit\파일명.sql"
```
- **주의**: SQL 파일은 반드시 Windows 경로(`C:\Users\tit\`)에 위치해야 함. `/tmp/` 등 Linux 경로는 sqlplus에서 접근 불가
- **주의**: sqlplus SQL 파일에 한글 주석 넣으면 인코딩 깨져서 INSERT/UPDATE 실패함. 한글 데이터는 UNISTR 사용하거나 주석은 영문으로.
- **주의**: UNISTR도 CASE WHEN 비교 시 ORA-12704 (character set mismatch) 발생 가능. 한글 컬럼 값 비교가 필요하면 Java 레벨에서 처리 권장.

## 프로젝트 구조
```
src/main/java/my/
├── api/              # REST Controller (12개)
├── domain/           # Service(interface+impl) + Mapper + VO + DTO
├── annotation/       # @RequireRole, @ValidSettlementRatio
├── aop/              # RoleCheckAspect
├── common/           # ApiResponse, ErrorCode, 예외 클래스, BankCodeResolver
├── enums/            # Role(ADMIN,BOOK_OWNER,CUSTOMER,EMPLOYEE), BookState
├── filter/           # JwtFilter
├── jwt/              # JwtProvider
└── validator/
src/main/resources/mybatis/mapper/  # MyBatis XML (12개)
```

## Identity 시퀀스 매핑 (INSERT 시 필수)
프로젝트는 selectKey + CURRVAL 패턴을 사용한다. useGeneratedKeys 사용하지 않음.
```
USERS                    → ISEQ$$_78221
BOOK_CASE_TYPE           → ISEQ$$_78216
BOOK_CASE                → ISEQ$$_78225
BOOK_CASE_OCCUPIED_RECORD → ISEQ$$_78234
BOOK                     → ISEQ$$_78230
BOOK_OWNER_SETTLEMENT    → ISEQ$$_78238
BOOK_SALE_RECORD         → ISEQ$$_78242  (GENERATED BY DEFAULT - ID를 명시적으로 넘김)
SETTLEMENT_RATIO         → ISEQ$$_77702
RENTAL_SETTLEMENT        → ISEQ$$_78284
DEPOSIT                  → ISEQ$$_78799
DEPOSIT_RENTAL_OFFSET    → ISEQ$$_78803
```

### INSERT 매퍼 작성 패턴
```xml
<insert id="insert" parameterType="...VO">
    <selectKey keyProperty="id" resultType="long" order="AFTER">
        SELECT "ISEQ$$_XXXXX".CURRVAL FROM DUAL
    </selectKey>
    INSERT INTO 테이블 (컬럼들) VALUES (값들)
</insert>
```
- BOOK_SALE_RECORD만 예외: BOOK.ID를 그대로 사용 (1:1 관계) → ID를 명시적으로 INSERT

## 비즈니스 정책

### 정산 정책 (변경됨)
- ~~구 정책: 책 판매 시 Settlement 생성 (settledAt=NULL) → 정산 시 settledAt 업데이트~~
- **신 정책: 정산 실행(POST /settlements) 시에만 Settlement 생성 (settledAt 즉시 설정)**
- 미정산 = BOOK_SALE_RECORD에서 BOOK_OWNER_SETTLEMENT_ID IS NULL인 레코드
- 정산 완료 = BOOK_OWNER_SETTLEMENT에 레코드 존재 (항상 settledAt이 있음)

### 정산 정책 (변경됨 - 임대료 상계 제거)
- ~~구 정책: 정산 실행 시 연체 임대료를 정산금에서 FIFO 공제 후 차액만 송금~~
- **신 정책: 정산 실행 시 ownerAmount 전액을 송금. 연체 임대료 공제는 보증금 스케줄러가 담당**
- 정산에서는 금액 계산 → 송금 → DB 기록만 수행 (상계 로직 없음)
- ~~SETTLEMENT_RENTAL_OFFSET 테이블~~ → DROP됨 (DEPOSIT_RENTAL_OFFSET으로 대체)
- ~~BOOK_OWNER_SETTLEMENT.DEDUCTED_RENTAL_AMOUNT / ACTUAL_PAYOUT_AMOUNT~~ → 컬럼 제거됨

### 배치 정산 (구현 완료)
- **수동**: Admin이 `POST /api/settlements/batch` 호출 → 미정산 판매기록이 있는 전체 BookOwner 일괄 정산
- **자동**: `SettlementScheduler` - 매월 1일 06:00 `@Scheduled(cron)` 실행
- **실패 처리**: 개별 BookOwner 정산 실패 시 건너뛰고 다음 진행 (로그 경고)
- **`@EnableScheduling`**: BookshareApplication에 적용됨

### 정산 실행 검증 순서 + 송금 흐름
1. saleRecordIds 비어있는지
2. 책소유주 존재 여부
3. 계좌 정보 등록 여부
4. saleRecordIds가 모두 해당 bookOwner 소유인지 (BOOK JOIN)
5. 이미 정산된 기록이 아닌지
6. 금액 계산 (sumAmountsByIds: 판매 시점 비율로 ownerAmount 산출)
7. 토스페이먼츠 송금 (ownerAmount 전액, TossPaymentService.transfer())
8. BOOK_OWNER_SETTLEMENT INSERT (금액 + payoutKey + transferStatus) → sale_record들의 settlement_id UPDATE

### 토스페이먼츠 연동
- `TossPaymentService.transfer(bankCode, accountNumber, amount, holderName)` → `TossTransferResponseDto`
- 구현체: `TossPaymentServiceImpl` (RestTemplate + Basic Auth)
- 설정값: `toss.payments.secret-key`, `toss.payments.base-url` (application.yml / .env)
- 송금 실패 시 `SETTLEMENT_TRANSFER_FAIL` 예외 → @Transactional 롤백
- `BankCodeResolver`: 은행명 → 2자리 코드 변환 유틸리티 (bankCode가 null일 때 폴백)
- bankName은 BankCodeResolver에 등록된 한글 은행명만 유효 (국민은행, 신한은행, 하나은행 등). 미등록 은행명이면 `BANK_CODE_NOT_FOUND` 예외 발생

#### 토스 지급대행 API 현황 (MVP 단계)
- **현재**: `TossPaymentServiceImpl`은 `/v1/payouts` 호출하는 단순 구현. 실제 토스 지급대행은 V2 API(`/v2/payouts`)로 별도 계약 + JWE 암호화 + 셀러 등록이 필요하여 현재 사용 불가
- **테스트**: `TestTossPaymentService`(@Primary)가 Mock 응답 반환 → JUnit은 항상 Mock 사용
- **MVP 전략**: 정산 실행 시 금액 계산/검증/DB 기록까지만 처리하고, 실제 송금은 관리자가 수동 이체. 사업 확장 시 토스 지급대행 계약(사업자등록 + 연 11만원) 후 실제 구현체 교체
- **토스 지급대행 실제 연동 시 필요사항**: V2 API 엔드포인트, 보안 키(64자 hex)로 JWE 암호화, `TossPayments-api-security-mode: ENCRYPTION` 헤더, 셀러 등록 → 잔액 확인 → 지급 요청 3단계 흐름
- **.env에 `TOSS_SECRET_KEY` 설정 완료** (test_sk_ 테스트 키). 단, 지급대행 계약 없이는 401 반환됨

#### Spring Profile 기반 Mock/실제 구현체 분리
- **문제**: 사업자등록 + 토스 지급대행 계약 없이는 실제 송금 API 테스트 불가 (401 반환)
- **해결**: Spring Profile을 활용하여 dev/prod 환경별 구현체 자동 전환
- **구조**:
  - `TossPaymentService` (인터페이스) — 송금 계약 정의
  - `TossPaymentServiceImpl` (`@Profile("!dev")`) — 실제 토스 API 호출 (prod 환경)
  - `MockTossPaymentService` (`@Profile("dev")`, `@Primary`) — 가짜 성공 응답 반환 (dev 환경)
  - `TestTossPaymentService` (src/test, `@Primary`) — JUnit 전용 Mock
- **환경 전환**: `application.yml`의 `spring.profiles.active` 값만 변경
  - `dev` → Mock 사용 (개발/시연용, 송금 없이 정산 흐름 전체 동작)
  - `prod` (또는 미지정) → 실제 토스 API 호출
- **전환 시나리오**: 사업자등록 + 토스 계약 완료 후 `dev` → `prod`로 변경하면 실제 송금 활성화

### COMMON_CODE 참조 무결성 (복합 FK + 앱 레벨 검증)
COMMON_CODE 테이블은 복합 PK (GROUP_CODE, CODE). 3개 테이블이 참조:

| 테이블 | GROUP_CODE_ID (DEFAULT) | COMMON_CODE_ID | FK 이름 | 앱 레벨 검증 |
|---|---|---|---|---|
| BOOK_CASE | 'LOCATION' | 위치 코드 (01, 02, 03) | FK_BC_COMMON_CODE | validateLocationCode() |
| BOOK | 'BOOK_TYPE' | 책 분류 코드 | FK_BOOK_COMMON_CODE | validateBookTypeCode() |
| BOOK_SALE_RECORD | 'BUY_TYPE' | 구매 유형 코드 (01~05) | FK_BSR_COMMON_CODE | selectByGroupCodeAndCode() |

- 각 테이블에 `GROUP_CODE_ID` 컬럼 (VARCHAR2, NOT NULL, DEFAULT 설정)
- 복합 FK: `(GROUP_CODE_ID, COMMON_CODE_ID)` → `COMMON_CODE (GROUP_CODE, CODE)`
- INSERT 시 서비스 코드에서 `setGroupCodeId("LOCATION"/"BOOK_TYPE"/"BUY_TYPE")` 명시 필수
- CommonCode 조회 API: `GET /api/common-codes?groupCode=LOCATION` (CommonCodeController)

### COMMON_CODE 데이터
```
GROUP_CODE  | CODE | CODE_NAME
LOCATION    | 01   | 1층 A구역
LOCATION    | 02   | 1층 B구역
LOCATION    | 03   | 2층 A구역
BOOK_TYPE   | 01~10| 소설, 역사, 스포츠, 과학, 자기계발, 경제/경영, 에세이, 만화, 외국문학, 기타
BUY_TYPE    | 01~05| 신용카드, 현금, 체크카드, 계좌이체, 간편결제
```

### 조건부 Unique Index 패턴
Oracle의 "NULL은 인덱스에서 제외" 특성을 이용한 패턴:
```sql
CREATE UNIQUE INDEX 인덱스명 ON 테이블 (
    CASE WHEN 조건컬럼 IS NULL THEN 유니크대상컬럼 END
);
```
적용 현황:
- USERS.EMAIL: DELETED_AT IS NULL인 행만 UNIQUE (소프트 삭제된 이메일 재사용 가능)
- BOOK_CASE_OCCUPIED_RECORD: UN_OCCUPIED_AT IS NULL인 행만 BOOK_CASE_ID UNIQUE (책장당 활성 점유 1건 제한)
- BOOK_CASE_TYPE.CODE: UNIQUE 제약조건 (UQ_BOOK_CASE_TYPE_CODE) — 동일 코드 중복 생성 불가

### 소프트 삭제
- USERS 테이블의 DELETED_AT 컬럼 사용 (NULL이면 활성)
- BOOK 테이블의 DELETED_AT 컬럼 사용 (회수 완료 시 SYSTIMESTAMP 세팅)

### 임대료 정산 정책
- BOOK_CASE_OCCUPIED_RECORD에 `EXPIRATION_DATE`(만기일자), `SUSPENDED_AT`(중지 시각) 컬럼 존재
- 보증금은 별도 DEPOSIT 테이블로 분리 (BCOR 1:1 참조)
- 점유(occupy) 생성 시 만기일자까지 월별 RENTAL_SETTLEMENT 레코드를 일괄 생성 (선불 청구서 패턴)
- RENTAL_SETTLEMENT는 책소유주별 + 월별로 생성되며, 금액과 정산 상태를 관리
- 임대료 납부 기한: 매월 말일

#### 보증금(DEPOSIT) 정책
- 보증금은 DEPOSIT 테이블에 별도 관리 (BCOR.ID 1:1 참조)
- 금액은 클라이언트 입력 없이 자동 초기화: `BOOK_CASE → BOOK_CASE_TYPE.MONTHLY_PRICE`
- occupy 시 해당 책장의 BookCaseType을 조회하여 monthlyPrice를 DEPOSIT.AMOUNT로 세팅
- TODO: Phase 2에서 DepositMapper.insert()로 보증금 INSERT 추가 (현재 occupy에 TODO 주석)

#### 입거 시 결제 (일할 계산)
- 입거 시 **보증금 + 입거월 잔여일 일할 임대료**를 납부해야 점유 시작
- 일할 계산 공식: `월 임대료 / 해당 월 총 일수 × 남은 일수` (원 미만 절사)
- 예시: 월 임대료 50,000원, 2월(28일) 15일 입거 → 50,000 / 28 × 14 = 25,000원 + 보증금 50,000원
- 입거월의 RENTAL_SETTLEMENT 레코드는 일할 계산된 금액으로 생성
- 이후 월(다음 달 1일~)부터는 정상 월 임대료로 생성

#### BOOK_CASE_OCCUPIED_RECORD 추가 컬럼
| 컬럼 | 타입 | 설명 |
|---|---|---|
| EXPIRATION_DATE | DATE NOT NULL | 만기일자 |
| SUSPENDED_AT | TIMESTAMP NULL | 중지 시각 (NULL=정상, NOT NULL=중지 상태) |

#### RENTAL_SETTLEMENT 테이블
| 컬럼 | 타입 | 설명 |
|---|---|---|
| ID | NUMBER (IDENTITY) | PK |
| OCCUPIED_RECORD_ID | NUMBER (FK) | BOOK_CASE_OCCUPIED_RECORD.ID 참조 |
| BOOK_OWNER_ID | NUMBER (FK) | 책소유주 ID |
| TARGET_MONTH | VARCHAR2(7) | 대상 월 ('YYYY-MM') |
| AMOUNT | NUMBER | 월 임대료 (생성 시점 MONTHLY_PRICE 고정) |
| STATUS | VARCHAR2(20) DEFAULT 'UNPAID' | UNPAID / PAID / CANCELLED |
| DEDUCTED_AMOUNT | NUMBER DEFAULT 0 | 상계로 공제된 누적 금액 |
| REMAINING_AMOUNT | NUMBER | 남은 임대료 (= AMOUNT - DEDUCTED_AMOUNT) |
| PAID_AT | TIMESTAMP | 결제 확인 시각 |
| CREATED_AT | TIMESTAMP DEFAULT SYSTIMESTAMP | 생성 시각 |

- 제약조건: `UNIQUE (OCCUPIED_RECORD_ID, TARGET_MONTH)` — 동일 점유 + 동일 월 중복 방지
- 제약조건: `CHECK (STATUS IN ('UNPAID', 'PAID', 'CANCELLED'))`

#### DEPOSIT 테이블 (보증금)
| 컬럼 | 타입 | 설명 |
|---|---|---|
| ID | NUMBER (IDENTITY) | PK (ISEQ$$_78799) |
| OCCUPIED_RECORD_ID | NUMBER (FK, UNIQUE) | BOOK_CASE_OCCUPIED_RECORD.ID 참조 (1:1) |
| AMOUNT | NUMBER NOT NULL | 보증금 원금 (= 월 임대료) |
| REMAINING_AMOUNT | NUMBER NOT NULL | 잔여 보증금 (공제 후 남은 금액) |
| STATUS | VARCHAR2(20) DEFAULT 'HELD' | HELD(보관중) / DEPLETED(소진) / RETURNED(반환) |
| CREATED_AT | TIMESTAMP DEFAULT SYSTIMESTAMP | 생성 시각 |

- 제약조건: `UNIQUE (OCCUPIED_RECORD_ID)` — 점유 1건당 보증금 1건
- 제약조건: `CHECK (STATUS IN ('HELD', 'DEPLETED', 'RETURNED'))`

#### DEPOSIT_RENTAL_OFFSET 테이블 (보증금-임대료 상계 내역)
| 컬럼 | 타입 | 설명 |
|---|---|---|
| ID | NUMBER (IDENTITY) | PK (ISEQ$$_78803) |
| DEPOSIT_ID | NUMBER (FK) | DEPOSIT.ID 참조 |
| RENTAL_SETTLEMENT_ID | NUMBER (FK) | RENTAL_SETTLEMENT.ID 참조 |
| OFFSET_AMOUNT | NUMBER | 이 건에서 공제한 금액 |
| CREATED_AT | TIMESTAMP DEFAULT SYSTIMESTAMP | 생성 시각 |

- N:N 관계: 하나의 보증금이 여러 연체 임대료를 공제, 하나의 임대료가 여러 차례에 걸쳐 부분 공제 가능

#### 보증금 연체 공제 스케줄러 (구현 예정)
- **실행 시점**: 매월 1일 05:00 (`@Scheduled(cron)`) — 정산 스케줄러(06:00)보다 먼저 실행
- **대상**: UN_OCCUPIED_AT IS NULL인 활성 점유 레코드 (BCOR)
- **연체 판정**: TARGET_MONTH < 현재 월 AND STATUS='UNPAID' AND REMAINING_AMOUNT > 0
- **공제 순서**: FIFO (오래된 연체 임대료부터, TARGET_MONTH ASC)
- **공제 한도**: DEPOSIT.REMAINING_AMOUNT 한도까지만 공제
- **부분 공제**: 임대료 50,000원 중 잔여 보증금 30,000원 → RENTAL_SETTLEMENT.REMAINING_AMOUNT=20,000 유지
- **공제 이력**: DEPOSIT_RENTAL_OFFSET 테이블에 N:N 상계 내역 기록

#### 단계적 제재 정책 (보증금 소진 후)
1. **보증금 소진** (DEPOSIT.REMAINING_AMOUNT = 0): STATUS → 'DEPLETED', 로그 경고 출력
2. **소진 후 추가 연체 발생**: BCOR.SUSPENDED_AT에 SYSTIMESTAMP 설정 → **중지 상태**
   - 중지 상태에서는 판매 정산금을 받을 수 없음 (정산 스케줄러에서 제외)
   - 중지 해제 조건: 미납 임대료 전액 납부 + 보증금 재납부
3. **다음 스케줄러 실행 시 여전히 SUSPENDED**: **강제 퇴거** 처리
   - unOccupyProcess 실행 (책 상태 NORMAL → SHOULD_BE_RETRIEVED)
   - 로그로 강제 퇴거 알림 기록
- **알림**: 현재 알림 인프라 없음 → 로그만 남기는 것으로 처리

#### 조기 퇴거 정책
- 조기 퇴거는 언제든 가능
- 퇴거 시 UNPAID 상태인 임대료를 모두 납부해야 퇴거 처리 완료
- 납부 완료 후 unOccupyProcess 실행

#### 임대료 자동 납부 처리 (추후 구현 예정)
- **방식**: PG사 온라인 결제 (토스페이먼츠) + Webhook 자동 처리
- **흐름**: 프론트 결제 버튼 클릭 → 토스 결제창 → 결제 완료 → PG사 Webhook(`POST /api/webhooks/toss`) → 서버에서 자동으로 `RENTAL_SETTLEMENT.STATUS → PAID` 처리
- **기반**: 이미 `TossPaymentService`가 존재하므로 확장 가능
- **현재(MVP)**: 관리자가 입금 확인 후 수동 납부 처리 (`POST /api/rental-settlements/{id}/pay`)
- **전환 시 필요사항**: 토스페이먼츠 결제 위젯 프론트 연동, Webhook 수신 엔드포인트 구현, 결제 검증 로직

#### 연체 알림 (현재: 로그만)
- 보증금 소진, 중지 상태, 강제 퇴거 시 로그 경고 출력
- 추후 알림 인프라 구축 시 점주(ADMIN)와 책소유주(BOOK_OWNER) 양쪽에 알람/문자 발송 예정

#### 계약 연장 정책
- 연장은 언제든 가능
- 연장 시 OR의 EXPIRATION_DATE를 새로운 만기일로 UPDATE
- 기존 만기일 이후 ~ 새 만기일까지 추가 RENTAL_SETTLEMENT 레코드 일괄 생성

### Book 상태 전이
```
NORMAL → SOLD (판매 시)
NORMAL → SHOULD_BE_RETRIEVED (임대 종료 시)
SHOULD_BE_RETRIEVED → soft delete (회수 시, DELETED_AT = SYSTIMESTAMP)
```

## 개발 진행 상황

### 기능 구현: 전부 완료
- Phase 1~3: 정산비율 설정, 책장 타입/등록, BookOwner 등록, 점유, 책 등록, 판매
- Phase 4: 미정산 조회, 정산 실행
- Phase 5: 책장 임대 종료, 회수 대기 목록, 책 회수
- Phase 6: 조회 API
- Phase 7: 토스페이먼츠 송금 연동 (settle() 시 실제 송금)

### 코드 품질 개선: 완료
- DTO 유효성 검증 (@Valid + Jakarta Validation 어노테이션)
- 권한 체크 (@RequireRole) 전 컨트롤러 적용
- soft delete 조건 (DELETED_AT IS NULL) 쿼리 보완
- @Transactional 쓰기 메서드 전체 적용
- GlobalExceptionHandler: DataIntegrityViolationException 처리 추가
- 중복 검증 (email, phone, residentNumber) UserAuthServiceImpl.save()에 중앙화
- COMMON_CODE 참조 무결성: 복합 FK (DB) + 앱 레벨 검증 (3개 테이블)
- BookCaseCreateDto: locationName → locationCode 리팩토링 (코드 직접 전달 방식)
- BookRegisterDto: bookType → bookTypeCode 리팩토링 (코드 직접 전달 방식)
- CommonCode 조회 API 추가 (GET /api/common-codes?groupCode=)

## 테스트 실행 방법
WSL 환경에서 Windows의 Maven을 통해 테스트 실행:
```bash
cd "/mnt/c/Users/tit/OneDrive/바탕 화면/bookshare" && cmd.exe /c "C:\Users\tit\run_test.cmd" 2>&1 | tail -10
```
- `run_test.cmd`는 `C:\Users\tit\` 에 위치
- 결과 마지막 10줄만 보면 `Tests run: 140, Failures: 0` 형태로 요약됨
- 실패 시 `| tail -10` 대신 `| grep -E "Tests run:|FAIL|ERROR.*Test" | head -30` 으로 실패 테스트 확인
- 현재 전체 테스트 수: **141개**

## 테스트 작성 패턴
```java
@SpringBootTest
@Transactional  // 테스트 후 자동 롤백
class XxxTest {
    // @Autowired로 실제 서비스 주입 (통합 테스트)
    // uniqueCode() → UUID.randomUUID().toString().substring(0,8) 로 유니크 데이터 생성
    // @DisplayName 한글로 작성
    // AssertJ 사용 (assertThat, assertThatThrownBy)
}
```
- 테스트 데이터 생성 순서: 정산비율 설정 → 책장타입 → 책장 → BookOwner(계좌포함) → 점유 → 책등록 → 판매
- 테스트 위치: `src/test/java/my/domain/{도메인}/`
- **중복 방지 필수**: phone, email, residentNumber, BookCaseType code는 반드시 `uniqueCode()` 기반 유니크 값 사용 (중복 검증 로직 때문)
- **bankName**: 테스트에서 bankName은 `"국민은행"` 등 BankCodeResolver에 등록된 유효한 한글 은행명 사용 (`"KB"` 등 약어 사용 금지)
- **locationCode**: 책장 생성 시 `setLocationCode("01")` 사용 (COMMON_CODE LOCATION 그룹의 CODE 값). `"1층 A구역"` 등 이름이 아닌 코드 직접 전달
- **bookTypeCode**: 책 등록 시 `setBookTypeCode("04")` 사용 (COMMON_CODE BOOK_TYPE 그룹의 CODE 값). `"과학"` 등 이름이 아닌 코드 직접 전달
- **buyTypeCommonCode**: 판매 기록 생성 시 `setBuyTypeCommonCode("01")` 사용 (COMMON_CODE BUY_TYPE 그룹의 CODE 값)
- soft delete 검증 시: `bookMapper.selectByIdIncludeDeleted(id)` 사용 (selectById는 DELETED_AT IS NULL 조건 포함)

## DTO / VO 패턴 규칙
- **VO**: DB 매핑 객체 (MyBatis resultMap). API 응답으로도 사용
- **DTO**: API 요청 전용. 유효성 검증 어노테이션은 DTO에만 부여
- **Controller**: 요청은 DTO로 받고, 서비스에 전달. 응답은 VO 반환
- **민감 필드**: UserVO의 `password`, `residentNumber`에 `@JsonIgnore` 적용 (API 응답에서 제외)
- VO를 `@RequestBody`로 직접 받지 않는다 (반드시 DTO 사용)

## 주요 참고 문서
- `BOOKSHARE_개발순서_및_서비스플로우.md` - 서비스 플로우 및 체크 로직

[//]: # (- `API_명세서_v2.html` - API 스펙)

[//]: # (- `erd.pdf` - ERD)

---

## TODO - 코드 분석 기반 개선 목록

### 즉시 수정 (버그/보안)
- [ ] SettlementController.findAllCompleted() 버그 — findAll()과 동일 결과 반환 (정산 완료 필터링 안 됨)
- [ ] JwtFilter 화이트리스트 startsWith → equals 변경 — 경로 prefix 매칭으로 인증 우회 가능
- [ ] BookCaseController 경로 충돌 해결 — `/{book-case-id}`와 `/{bookowner-id}`가 동일 패턴
- [ ] UserUpdateDto 유효성 검증 어노테이션 추가 + CustomerController @Valid 누락 수정

### 높음 - 보안
- [ ] 로그인 Brute-force 방어 (계정 잠금 또는 Rate Limiting)
- [ ] 주민번호 평문 저장 → 암호화 (현재 DB에 평문 저장)
- [ ] BookRegisterDto에서 bookState 클라이언트 설정 방지 (서버에서 NORMAL 강제)
- [ ] CommonCodeController @RequireRole 추가 (현재 권한 체크 없음)

### 높음 - 정산 로직
- [ ] settleAll() self-invocation 트랜잭션 문제 — REQUIRES_NEW + 별도 빈 분리로 프록시 우회 해결

  > **문제 원인**:
  > - settleAll()에서 같은 클래스 내 this.settle() 호출 → Spring AOP 프록시를 거치지 않음 → settle()의 @Transactional이 무시됨
  > - ApplicationException이 RuntimeException을 상속 → settle() 내부에서 예외 발생 시 트랜잭션이 rollback-only로 마킹됨
  > - settleAll()의 catch가 예외를 잡아도 트랜잭션은 이미 rollback-only → 나머지 BookOwner 정산도 커밋 시점에 전체 롤백
  > - **결과**: 한 BookOwner 정산 실패 시 전체 배치가 롤백됨 ("개별 실패 시 건너뛰고 다음 진행" 정책과 모순)
  >
  > **해결 방안**:
  > - settle() 메서드를 별도 빈(SettlementExecutor 등)으로 분리하여 Spring 프록시가 동작하도록 함
  > - 또는 TransactionTemplate을 사용하여 프로그래밍 방식으로 트랜잭션 제어
  > - settle()에 @Transactional(propagation = REQUIRES_NEW) 적용 (단, self-invocation이면 무의미하므로 반드시 별도 빈 분리 필요)

- [ ] 토스 송금 후 DB 실패 시 이중 송금 방지 — Settlement PENDING 상태로 선 INSERT 후 송금 → 성공 시 상태 갱신
- [ ] pay()와 보증금 공제 스케줄러 동시 실행 방지 — 같은 RENTAL_SETTLEMENT에 대한 동시 상태 변경 경합
- [ ] BigDecimal.intValue() → intValueExact() 변경 — 오버플로우 시 무시되는 문제 방지

### 높음 - 보증금/임대료 (구현 예정)
- [ ] Phase 2: MyBatis 매핑 (DepositVO, DepositMapper, DepositRentalOffsetVO/Mapper, XML)
- [ ] Phase 3: occupy()에서 DEPOSIT INSERT, unOccupyProcess에서 보증금 반환 처리
- [ ] Phase 4: 보증금 연체 공제 스케줄러 (DepositService, 매월 1일 05:00, FIFO 공제, SUSPENDED 처리, 강제 퇴거)
- [ ] Phase 5: 보증금/연체 공제 관련 테스트 작성

### 높음 - 비즈니스 로직
- [ ] sellBooks()에 고객(Customer) 존재 검증 추가 — customerId 유효성 미검증
- [ ] occupy()에 BookOwner 존재 검증 추가 — bookOwnerId 유효성 미검증

### 중간
- [ ] SELECT * → 필요 컬럼만 명시 (MyBatis XML 전반)
- [ ] 전체 조회 API 페이징 적용 (현재 전부 무한 조회)
- [ ] 컨트롤러 레이어 테스트 추가 (MockMvc 기반)
- [ ] 계약 연장 API 구현 (정책은 정의됨, 구현 미완)
- [ ] 만기일 자동 퇴거 처리 (스케줄러)
- [ ] 정산 스케줄러에서 SUSPENDED 상태 책소유주 제외 로직 추가
- [ ] 로깅 레벨 프로파일별 분리 (dev: DEBUG, prod: INFO)
- [ ] application-test.yml 분리 (테스트 전용 설정)
- [ ] HTTP 응답 코드 일관성 — ResponseEntity 사용으로 상황별 적절한 상태 코드 반환
- [ ] 정산 비율 API 경로 RESTful 변경 (현재 비표준 경로)
- [ ] 스케줄러 예외 처리/알림 추가 (현재 예외 발생 시 무시됨)
- [ ] dev 프로파일에서 스케줄러 비활성화 (@ConditionalOnProperty 등)

### 낮음
- [ ] CORS 설정 (프론트엔드 연동 시 필요)
- [ ] 패키지 네이밍 수정 — `settlments` 오타 → `settlements`, snake_case 통일
- [ ] Unused import 정리
- [ ] BookSoldRecordMapper foreach IN절 1000개 제한 대응 (Oracle IN clause 제한)
- [ ] POST /books/retrieve → PATCH 변경 (RESTful 관점)

# BookShare 개발 레퍼런스

> CLAUDE.md에서 분리된 상세 참조 문서. 해당 도메인 작업 시에만 참고.

---

## 1. Identity 시퀀스 매핑 (INSERT 시 필수)

프로젝트는 selectKey + CURRVAL 패턴을 사용한다. useGeneratedKeys 사용하지 않음.

```
USERS                    → ISEQ$$_78221
BOOK_CASE_TYPE           → ISEQ$$_78216
BOOK_CASE                → ISEQ$$_78225
BOOK_CASE_OCCUPIED_RECORD → ISEQ$$_78234
BOOK                     → ISEQ$$_78230
BOOK_OWNER_SETTLEMENT    → ISEQ$$_78238
BOOK_SALE_RECORD         → ISEQ$$_78242  (GENERATED BY DEFAULT - ID를 명시적으로 넘김)
SETTLEMENT_RATIO         → ISEQ$$_77702
RENTAL_SETTLEMENT        → ISEQ$$_78284
DEPOSIT                  → ISEQ$$_78799
DEPOSIT_RENTAL_OFFSET    → ISEQ$$_78803
```

### INSERT 매퍼 작성 패턴
```xml
<insert id="insert" parameterType="...VO">
    <selectKey keyProperty="id" resultType="long" order="AFTER">
        SELECT "ISEQ$$_XXXXX".CURRVAL FROM DUAL
    </selectKey>
    INSERT INTO 테이블 (컬럼들) VALUES (값들)
</insert>
```
- BOOK_SALE_RECORD만 예외: BOOK.ID를 그대로 사용 (1:1 관계) → ID를 명시적으로 INSERT

---

## 2. 비즈니스 정책 상세

### 정산 정책
- 정산 실행(POST /settlements) 시에만 Settlement 생성 (settledAt 즉시 설정)
- 미정산 = BOOK_SALE_RECORD에서 BOOK_OWNER_SETTLEMENT_ID IS NULL인 레코드
- 정산 완료 = BOOK_OWNER_SETTLEMENT에 레코드 존재 (항상 settledAt이 있음)
- 정산 시 ownerAmount 전액을 송금. 연체 임대료 공제는 보증금 스케줄러가 담당
- ~~SETTLEMENT_RENTAL_OFFSET 테이블~~ → DROP됨 (DEPOSIT_RENTAL_OFFSET으로 대체)
- ~~BOOK_OWNER_SETTLEMENT.DEDUCTED_RENTAL_AMOUNT / ACTUAL_PAYOUT_AMOUNT~~ → 컬럼 제거됨

### 배치 정산
- **수동**: Admin이 `POST /api/settlements/batch` 호출 → 미정산 판매기록이 있는 전체 BookOwner 일괄 정산
- **자동**: `SettlementScheduler` - 매월 1일 06:00 `@Scheduled(cron)` 실행
- **실패 처리**: 개별 BookOwner 정산 실패 시 건너뛰고 다음 진행 (로그 경고)
- **`@EnableScheduling`**: BookshareApplication에 적용됨

### 정산 실행 검증 순서 + 송금 흐름
1. saleRecordIds 비어있는지
2. 책소유주 존재 여부
3. 계좌 정보 등록 여부
4. saleRecordIds가 모두 해당 bookOwner 소유인지 (BOOK JOIN)
5. 이미 정산된 기록이 아닌지
6. 금액 계산 (sumAmountsByIds: 판매 시점 비율로 ownerAmount 산출)
7. 토스페이먼츠 송금 (ownerAmount 전액, TossPaymentService.transfer())
8. BOOK_OWNER_SETTLEMENT INSERT (금액 + payoutKey + transferStatus) → sale_record들의 settlement_id UPDATE

---

## 3. 토스페이먼츠 연동

### 기본 구조
- `TossPaymentService.transfer(bankCode, accountNumber, amount, holderName)` → `TossTransferResponseDto`
- 구현체: `TossPaymentServiceImpl` (RestTemplate + Basic Auth)
- 설정값: `toss.payments.secret-key`, `toss.payments.base-url` (application.yml / .env)
- 송금 실패 시 `SETTLEMENT_TRANSFER_FAIL` 예외 → @Transactional 롤백
- `BankCodeResolver`: 은행명 → 2자리 코드 변환 유틸리티
- bankName은 BankCodeResolver에 등록된 한글 은행명만 유효 (국민은행, 신한은행, 하나은행 등)

### 토스 지급대행 API 현황 (MVP 단계)
- **현재**: `TossPaymentServiceImpl`은 `/v1/payouts` 호출하는 단순 구현. 실제 토스 지급대행은 V2 API(`/v2/payouts`)로 별도 계약 + JWE 암호화 + 셀러 등록이 필요하여 현재 사용 불가
- **테스트**: `TestTossPaymentService`(@Primary)가 Mock 응답 반환 → JUnit은 항상 Mock 사용
- **MVP 전략**: 정산 실행 시 금액 계산/검증/DB 기록까지만 처리하고, 실제 송금은 관리자가 수동 이체
- **.env에 `TOSS_SECRET_KEY` 설정 완료** (test_sk_ 테스트 키). 단, 지급대행 계약 없이는 401 반환됨

### Spring Profile 기반 Mock/실제 구현체 분리
- `TossPaymentService` (인터페이스) — 송금 계약 정의
- `TossPaymentServiceImpl` (`@Profile("!dev")`) — 실제 토스 API 호출 (prod 환경)
- `MockTossPaymentService` (`@Profile("dev")`, `@Primary`) — 가짜 성공 응답 반환 (dev 환경)
- `TestTossPaymentService` (src/test, `@Primary`) — JUnit 전용 Mock
- **환경 전환**: `application.yml`의 `spring.profiles.active` 값만 변경 (`dev` / `prod`)

---

## 4. COMMON_CODE 참조 무결성

COMMON_CODE 테이블은 복합 PK (GROUP_CODE, CODE). 3개 테이블이 참조:

| 테이블 | GROUP_CODE_ID (DEFAULT) | COMMON_CODE_ID | FK 이름 | 앱 레벨 검증 |
|---|---|---|---|---|
| BOOK_CASE | 'LOCATION' | 위치 코드 (01, 02, 03) | FK_BC_COMMON_CODE | validateLocationCode() |
| BOOK | 'BOOK_TYPE' | 책 분류 코드 | FK_BOOK_COMMON_CODE | validateBookTypeCode() |
| BOOK_SALE_RECORD | 'BUY_TYPE' | 구매 유형 코드 (01~05) | FK_BSR_COMMON_CODE | selectByGroupCodeAndCode() |

- 각 테이블에 `GROUP_CODE_ID` 컬럼 (VARCHAR2, NOT NULL, DEFAULT 설정)
- 복합 FK: `(GROUP_CODE_ID, COMMON_CODE_ID)` → `COMMON_CODE (GROUP_CODE, CODE)`
- INSERT 시 서비스 코드에서 `setGroupCodeId("LOCATION"/"BOOK_TYPE"/"BUY_TYPE")` 명시 필수
- CommonCode 조회 API: `GET /api/common-codes?groupCode=LOCATION` (CommonCodeController)

### COMMON_CODE 데이터
```
GROUP_CODE  | CODE | CODE_NAME
LOCATION    | 01   | 1층 A구역
LOCATION    | 02   | 1층 B구역
LOCATION    | 03   | 2층 A구역
BOOK_TYPE   | 01~10| 소설, 역사, 스포츠, 과학, 자기계발, 경제/경영, 에세이, 만화, 외국문학, 기타
BUY_TYPE    | 01~05| 신용카드, 현금, 체크카드, 계좌이체, 간편결제
```

---

## 5. 조건부 Unique Index 패턴

Oracle의 "NULL은 인덱스에서 제외" 특성을 이용:
```sql
CREATE UNIQUE INDEX 인덱스명 ON 테이블 (
    CASE WHEN 조건컬럼 IS NULL THEN 유니크대상컬럼 END
);
```
적용 현황:
- USERS.EMAIL: DELETED_AT IS NULL인 행만 UNIQUE (소프트 삭제된 이메일 재사용 가능)
- BOOK_CASE_OCCUPIED_RECORD: UN_OCCUPIED_AT IS NULL인 행만 BOOK_CASE_ID UNIQUE (책장당 활성 점유 1건 제한)
- BOOK_CASE_TYPE.CODE: UNIQUE 제약조건 (UQ_BOOK_CASE_TYPE_CODE)

---

## 6. 임대료/보증금 테이블 스키마

### RENTAL_SETTLEMENT
| 컬럼 | 타입 | 설명 |
|---|---|---|
| ID | NUMBER (IDENTITY) | PK (ISEQ$$_78284) |
| OCCUPIED_RECORD_ID | NUMBER (FK) | BOOK_CASE_OCCUPIED_RECORD.ID 참조 |
| BOOK_OWNER_ID | NUMBER (FK) | 책소유주 ID |
| TARGET_MONTH | VARCHAR2(7) | 대상 월 ('YYYY-MM') |
| AMOUNT | NUMBER | 월 임대료 (생성 시점 MONTHLY_PRICE 고정) |
| STATUS | VARCHAR2(20) DEFAULT 'UNPAID' | UNPAID / PAID / CANCELLED |
| DEDUCTED_AMOUNT | NUMBER DEFAULT 0 | 상계로 공제된 누적 금액 |
| REMAINING_AMOUNT | NUMBER | 남은 임대료 (= AMOUNT - DEDUCTED_AMOUNT) |
| PAID_AT | TIMESTAMP | 결제 확인 시각 |
| CREATED_AT | TIMESTAMP DEFAULT SYSTIMESTAMP | 생성 시각 |

- `UNIQUE (OCCUPIED_RECORD_ID, TARGET_MONTH)`
- `CHECK (STATUS IN ('UNPAID', 'PAID', 'CANCELLED'))`

### DEPOSIT (보증금)
| 컬럼 | 타입 | 설명 |
|---|---|---|
| ID | NUMBER (IDENTITY) | PK (ISEQ$$_78799) |
| BOOK_OWNER_ID | NUMBER (FK, UNIQUE) | BOOK_OWNER.ID 참조 (1:1) |
| AMOUNT | NUMBER NOT NULL | 보증금 원금 |
| REMAINING_AMOUNT | NUMBER NOT NULL | 잔여 보증금 |
| STATUS | VARCHAR2(20) DEFAULT 'HELD' | HELD / DEPLETED / RETURNED |
| CREATED_AT | TIMESTAMP DEFAULT SYSTIMESTAMP | 생성 시각 |

### DEPOSIT_RENTAL_OFFSET (보증금-임대료 상계 내역)
| 컬럼 | 타입 | 설명 |
|---|---|---|
| ID | NUMBER (IDENTITY) | PK (ISEQ$$_78803) |
| DEPOSIT_ID | NUMBER (FK) | DEPOSIT.ID 참조 |
| RENTAL_SETTLEMENT_ID | NUMBER (FK) | RENTAL_SETTLEMENT.ID 참조 |
| OFFSET_AMOUNT | NUMBER | 이 건에서 공제한 금액 |
| CREATED_AT | TIMESTAMP DEFAULT SYSTIMESTAMP | 생성 시각 |

---

## 7. 보증금 연체 공제 스케줄러 상세

### 실행 정보
- **시점**: 매월 1일 05:00 (`@Scheduled(cron)`) — 정산 스케줄러(06:00)보다 먼저
- **구현체**: `DepositScheduler` → `DepositServiceImpl.processMonthlyOverdue()`
- **처리 단위**: BookOwner 단위 그룹핑

### 처리 흐름
1. 활성 점유 전체 조회 (`selectAllActive`)
2. BookOwner별 그룹핑 (`Collectors.groupingBy`)
3. 이미 SUSPENDED인 점유 → 강제 퇴거 (`unOccupyProcess`)
4. 각 점유의 연체 임대료 수집 (TARGET_MONTH < 현재월, UNPAID, REMAINING_AMOUNT > 0)
5. 보증금에서 FIFO 공제 (`Math.min(depositRemain, rentalRemain)`)
6. 공제 내역 기록 (DEPOSIT_RENTAL_OFFSET INSERT)
7. 보증금 소진 시 STATUS → DEPLETED
8. 소진 후 추가 연체 → BCOR.SUSPENDED_AT 설정
- **개별 실패 처리**: BookOwner 단위 try-catch, 로그 경고 후 다음 진행

### 단계적 제재 정책
1. **보증금 소진** (REMAINING_AMOUNT = 0): STATUS → DEPLETED
2. **소진 후 추가 연체**: BCOR.SUSPENDED_AT 설정 → 중지 상태 (정산 스케줄러에서 제외)
3. **다음 스케줄러에서 여전히 SUSPENDED**: 강제 퇴거 (unOccupyProcess)

### 임대료 관련 정책
- 입거 시 일할 계산: `월 임대료 / 해당 월 총 일수 × 남은 일수` (원 미만 절사)
- 조기 퇴거: 언제든 가능, UNPAID 임대료 전액 납부 후 퇴거 처리
- 계약 연장: EXPIRATION_DATE 업데이트 + 추가 RENTAL_SETTLEMENT 일괄 생성
- 임대료 자동 납부: 추후 토스페이먼츠 Webhook 연동 예정 (현재 관리자 수동 처리)

---

## 8. 개발 진행 상황

### 기능 구현: 전부 완료
- Phase 1~3: 정산비율, 책장 타입/등록, BookOwner, 점유, 책 등록, 판매
- Phase 4: 미정산 조회, 정산 실행
- Phase 5: 임대 종료, 회수 대기, 책 회수
- Phase 6: 조회 API
- Phase 7: 토스페이먼츠 송금 연동
- Phase 8: 보증금 연체 공제 스케줄러

### 보증금/연체 구현 현황
- [x] DepositVO, DepositRentalOffsetVO, Mapper + XML
- [x] DepositService / DepositServiceImpl (processMonthlyOverdue)
- [x] DepositScheduler (매월 1일 05:00)
- [x] BCOR: selectAllActive, updateSuspendedAt
- [x] RentalSettlement: selectOverdueByOccupiedRecordId, update(VO)
- [x] unOccupyProcess 미정산 판매기록 검증 (UNSETTLED_SALE_RECORD_EXISTS)
- [x] occupy()에서 DEPOSIT INSERT/적립
- [ ] unOccupyProcess에서 보증금 반환 처리
- [ ] 보증금/연체 공제 관련 테스트 작성

---

## 9. TODO - 코드 분석 기반 개선 목록

### 즉시 수정 (버그/보안)
- [ ] SettlementController.findAllCompleted() 버그 — findAll()과 동일 결과 반환
- [ ] JwtFilter 화이트리스트 startsWith → equals 변경 — 인증 우회 가능
- [ ] BookCaseController 경로 충돌 — `/{book-case-id}`와 `/{bookowner-id}` 동일 패턴
- [ ] UserUpdateDto 유효성 검증 + CustomerController @Valid 누락

### 높음 - 보안
- [ ] 로그인 Brute-force 방어
- [ ] 주민번호 암호화 (현재 평문 저장)
- [ ] BookRegisterDto bookState 클라이언트 설정 방지
- [ ] CommonCodeController @RequireRole 추가

### 높음 - 정산 로직
- [ ] settleAll() self-invocation 트랜잭션 문제 — REQUIRES_NEW + 별도 빈 분리
  > settle()을 별도 빈(SettlementExecutor)으로 분리 → Spring 프록시 동작 → @Transactional(REQUIRES_NEW) 적용
  > 현재: 한 BookOwner 실패 시 전체 배치 롤백 (정책 위반)
- [ ] 토스 송금 후 DB 실패 시 이중 송금 방지 — PENDING 선 INSERT
- [ ] pay()와 보증금 공제 스케줄러 동시 실행 방지
- [ ] BigDecimal.intValue() → intValueExact()

### 높음 - 보증금/임대료
- [ ] unOccupyProcess에서 보증금 반환 처리
- [ ] 보증금/연체 공제 관련 테스트 작성

### 높음 - 비즈니스 로직
- [ ] sellBooks()에 Customer 존재 검증 추가
- [ ] occupy()에 BookOwner 존재 검증 추가

### 중간
- [ ] SELECT * → 필요 컬럼만 명시
- [ ] 전체 조회 API 페이징
- [ ] 컨트롤러 레이어 테스트 (MockMvc)
- [ ] 계약 연장 API 구현
- [ ] 만기일 자동 퇴거 스케줄러
- [ ] 정산 스케줄러 SUSPENDED 제외
- [ ] 로깅 레벨 프로파일별 분리
- [ ] application-test.yml 분리
- [ ] HTTP 응답 코드 일관성 (ResponseEntity)
- [ ] 정산 비율 API 경로 RESTful 변경
- [ ] 스케줄러 예외 처리/알림
- [ ] dev 프로파일 스케줄러 비활성화

### 낮음
- [ ] CORS 설정
- [ ] 패키지 `settlments` 오타 → `settlements`
- [ ] Unused import 정리
- [ ] BookSoldRecordMapper IN절 1000개 제한 대응
- [ ] POST /books/retrieve → PATCH 변경

// BookShare DB Schema
// Generated from MyBatis mappers + VO classes + CLAUDE.md

// ============================================================
// COMMON_CODE (GROUP_CODE 테이블 포함)
// ============================================================

Table COMMON_CODE {
  GROUP_CODE VARCHAR2(50) [not null, note: 'LOCATION / BOOK_TYPE / BUY_TYPE']
  CODE VARCHAR2(10) [not null]
  CODE_NAME VARCHAR2(100)

  indexes {
    (GROUP_CODE, CODE) [pk]
  }

  Note: '''
  공통 코드 마스터.
  복합 PK (GROUP_CODE, CODE).
  LOCATION: 01(1층 A구역), 02(1층 B구역), 03(2층 A구역)
  BOOK_TYPE: 01~10 (소설, 역사, 스포츠, 과학, 자기계발, 경제/경영, 에세이, 만화, 외국문학, 기타)
  BUY_TYPE: 01~05 (신용카드, 현금, 체크카드, 계좌이체, 간편결제)
  '''
}

// ============================================================
// USERS (소프트 삭제 지원)
// ============================================================

Table USERS {
  ID NUMBER [pk, increment, note: 'ISEQ$$_78221']
  ROLE VARCHAR2(20) [note: 'ADMIN / BOOK_OWNER / CUSTOMER / EMPLOYEE']
  NAME VARCHAR2(100) [not null]
  PHONE VARCHAR2(20) [not null]
  EMAIL VARCHAR2(100) [not null]
  RESIDENT_NUMBER VARCHAR2(20) [not null]
  PASSWORD VARCHAR2(200) [not null]
  DELETED_AT TIMESTAMP [note: 'NULL이면 활성 (소프트 삭제)']

  indexes {
    (EMAIL) [name: 'UQ_USERS_EMAIL', note: 'Conditional unique: DELETED_AT IS NULL인 행만']
  }

  Note: '''
  사용자 테이블 (ADMIN, BOOK_OWNER, CUSTOMER, EMPLOYEE 공용).
  소프트 삭제: DELETED_AT IS NULL인 행만 활성.
  조건부 Unique Index: DELETED_AT IS NULL인 경우에만 EMAIL 유일성 보장.
  '''
}

// ============================================================
// CUSTOMER (USERS 1:1 서브타입)
// ============================================================

Table CUSTOMER {
  ID NUMBER [pk, ref: - USERS.ID, note: 'USERS.ID 참조 (1:1)']

  Note: '고객 서브타입 테이블. USERS에서 ROLE=CUSTOMER인 사용자와 1:1.'
}

// ============================================================
// BOOK_OWNER (USERS 1:1 서브타입)
// ============================================================

Table BOOK_OWNER {
  ID NUMBER [pk, ref: - USERS.ID, note: 'USERS.ID 참조 (1:1)']

  Note: '책소유주 서브타입 테이블. USERS에서 ROLE=BOOK_OWNER인 사용자와 1:1.'
}

// ============================================================
// ADDRESS (USERS 1:1)
// ============================================================

Table ADDRESS {
  ID NUMBER [pk, ref: - USERS.ID, note: 'USERS.ID 참조 (1:1)']
  CITY VARCHAR2(100)
  LOAD_ADDR VARCHAR2(200)
  SPECIFIC_ADDR VARCHAR2(200)

  Note: '사용자 주소. USERS와 1:1 관계.'
}

// ============================================================
// BANK_ACCOUNT (BOOK_OWNER 1:1)
// ============================================================

Table BANK_ACCOUNT {
  BOOK_OWNER_ID NUMBER [pk, ref: - BOOK_OWNER.ID, note: 'BOOK_OWNER.ID 참조 (1:1)']
  ACCOUNT_NUMBER VARCHAR2(50) [not null]
  BANK_NAME VARCHAR2(50) [not null, note: 'BankCodeResolver 등록 한글 은행명']
  BANK_CODE VARCHAR2(10) [note: '2자리 은행 코드']

  Note: '책소유주 계좌 정보. BOOK_OWNER와 1:1 관계.'
}

// ============================================================
// SETTLEMENT_RATIO (정산 비율)
// ============================================================

Table SETTLEMENT_RATIO {
  ID NUMBER [pk, increment, note: 'ISEQ$$_77702']
  OWNER_RATIO NUMBER [not null, note: '책소유주 정산 비율 (0~1)']
  STORE_RATIO NUMBER [not null, note: '서점 정산 비율 (0~1)']
  CREATED_AT TIMESTAMP [not null, default: 'SYSDATE']

  Note: '정산 비율 이력. 최신 레코드(ID DESC)가 현재 적용 비율.'
}

// ============================================================
// BOOK_CASE_TYPE (책장 유형)
// ============================================================

Table BOOK_CASE_TYPE {
  ID NUMBER [pk, increment, note: 'ISEQ$$_78216']
  CODE VARCHAR2(50) [unique, not null, note: 'UQ_BOOK_CASE_TYPE_CODE']
  MONTHLY_PRICE NUMBER [not null, note: '월 임대료']
  CREATED_AT TIMESTAMP [default: 'SYSTIMESTAMP']

  Note: '책장 유형 마스터. CODE 중복 불가 (UQ_BOOK_CASE_TYPE_CODE).'
}

// ============================================================
// BOOK_CASE (책장)
// ============================================================

Table BOOK_CASE {
  ID NUMBER [pk, increment, note: 'ISEQ$$_78225']
  GROUP_CODE_ID VARCHAR2(50) [not null, default: 'LOCATION', note: '복합 FK의 GROUP_CODE']
  COMMON_CODE_ID VARCHAR2(10) [not null, note: '위치 코드 (01, 02, 03)']
  BOOK_CASE_TYPE_ID NUMBER [not null, ref: > BOOK_CASE_TYPE.ID]

  Note: '''
  책장 테이블.
  복합 FK: (GROUP_CODE_ID, COMMON_CODE_ID) -> COMMON_CODE (GROUP_CODE, CODE)
  GROUP_CODE_ID 기본값 = LOCATION
  '''
}

// ============================================================
// BOOK_CASE_OCCUPIED_RECORD (책장 점유 기록)
// ============================================================

Table BOOK_CASE_OCCUPIED_RECORD {
  ID NUMBER [pk, increment, note: 'ISEQ$$_78234']
  BOOK_CASE_ID NUMBER [not null, ref: > BOOK_CASE.ID]
  BOOK_OWNER_ID NUMBER [not null, ref: > BOOK_OWNER.ID]
  OCCUPIED_AT TIMESTAMP [not null, default: 'SYSTIMESTAMP']
  UN_OCCUPIED_AT TIMESTAMP [note: 'NULL이면 현재 점유 중']
  EXPIRATION_DATE DATE [not null, note: '만기일자']
  SUSPENDED_AT TIMESTAMP [note: 'NULL=정상, NOT NULL=중지 상태']

  indexes {
    (BOOK_CASE_ID) [name: 'UQ_BCOR_ACTIVE', note: 'Conditional unique: UN_OCCUPIED_AT IS NULL인 행만 (책장당 활성 점유 1건)']
  }

  Note: '''
  책장 점유 이력.
  조건부 Unique Index: UN_OCCUPIED_AT IS NULL인 경우에만 BOOK_CASE_ID 유일성 보장.
  → 한 책장에 동시에 활성 점유 1건만 허용.
  '''
}

// ============================================================
// BOOK (도서)
// ============================================================

Table BOOK {
  ID NUMBER [pk, increment, note: 'ISEQ$$_78230']
  BOOK_OWNER_ID NUMBER [not null, ref: > BOOK_OWNER.ID]
  BOOK_CASE_ID NUMBER [not null, ref: > BOOK_CASE.ID]
  BOOK_NAME VARCHAR2(200) [not null]
  PUBLISHER_HOUSE VARCHAR2(200)
  PRICE NUMBER [not null]
  ENTERED_AT DATE [not null, default: 'SYSDATE']
  GROUP_CODE_ID VARCHAR2(50) [not null, default: 'BOOK_TYPE', note: '복합 FK의 GROUP_CODE']
  COMMON_CODE_ID VARCHAR2(10) [not null, note: '책 분류 코드 (01~10)']
  STATE VARCHAR2(30) [not null, default: 'NORMAL', note: 'NORMAL / SOLD / SHOULD_BE_RETRIEVED']
  DELETED_AT TIMESTAMP [note: 'NULL이면 활성 (회수 시 SYSTIMESTAMP)']

  Note: '''
  도서 테이블.
  복합 FK: (GROUP_CODE_ID, COMMON_CODE_ID) -> COMMON_CODE (GROUP_CODE, CODE)
  GROUP_CODE_ID 기본값 = BOOK_TYPE
  상태 전이: NORMAL -> SOLD (판매) / NORMAL -> SHOULD_BE_RETRIEVED (임대 종료) -> soft delete (회수)
  '''
}

// ============================================================
// BOOK_OWNER_SETTLEMENT (책소유주 판매 정산)
// ============================================================

Table BOOK_OWNER_SETTLEMENT {
  ID NUMBER [pk, increment, note: 'ISEQ$$_78238']
  BOOK_OWNER_ID NUMBER [not null, ref: > BOOK_OWNER.ID]
  SETTLED_AT TIMESTAMP [not null, default: 'SYSTIMESTAMP']
  TOTAL_AMOUNT NUMBER [not null, note: '총 판매 금액']
  OWNER_AMOUNT NUMBER [not null, note: '책소유주 정산 금액']
  STORE_AMOUNT NUMBER [not null, note: '서점 몫']
  PAYOUT_KEY VARCHAR2(100) [note: '토스 지급 키']
  TRANSFER_STATUS VARCHAR2(30) [note: '송금 상태']

  Note: '''
  책소유주 판매 정산 테이블.
  정산 실행(POST /settlements) 시에만 생성 (settledAt 즉시 설정).
  ownerAmount 전액 송금 (임대료 상계는 보증금 스케줄러가 담당).
  '''
}

// ============================================================
// BOOK_SALE_RECORD (판매 기록)
// ============================================================

Table BOOK_SALE_RECORD {
  ID NUMBER [pk, note: 'BOOK.ID와 1:1 (GENERATED BY DEFAULT, ISEQ$$_78242)']
  SOLD_AT TIMESTAMP [not null, default: 'SYSTIMESTAMP']
  SOLD_PRICE NUMBER [not null]
  CUSTOMER_ID NUMBER [not null, ref: > USERS.ID, note: '구매 고객 ID']
  GROUP_CODE_ID VARCHAR2(50) [not null, default: 'BUY_TYPE', note: '복합 FK의 GROUP_CODE']
  COMMON_CODE_ID VARCHAR2(10) [not null, note: '구매 유형 코드 (01~05)']
  BOOK_OWNER_SETTLEMENT_ID NUMBER [ref: > BOOK_OWNER_SETTLEMENT.ID, note: 'NULL이면 미정산']
  RATIO_ID NUMBER [not null, ref: > SETTLEMENT_RATIO.ID, note: '판매 시점 정산 비율']

  Note: '''
  판매 기록 테이블.
  BOOK과 1:1 관계 (BOOK.ID를 ID로 직접 사용).
  복합 FK: (GROUP_CODE_ID, COMMON_CODE_ID) -> COMMON_CODE (GROUP_CODE, CODE)
  GROUP_CODE_ID 기본값 = BUY_TYPE
  미정산 = BOOK_OWNER_SETTLEMENT_ID IS NULL
  '''
}

// ============================================================
// RENTAL_SETTLEMENT (임대료 정산)
// ============================================================

Table RENTAL_SETTLEMENT {
  ID NUMBER [pk, increment, note: 'ISEQ$$_78284']
  OCCUPIED_RECORD_ID NUMBER [not null, ref: > BOOK_CASE_OCCUPIED_RECORD.ID]
  BOOK_OWNER_ID NUMBER [not null, ref: > BOOK_OWNER.ID]
  TARGET_MONTH VARCHAR2(7) [not null, note: '대상 월 (YYYY-MM)']
  AMOUNT NUMBER [not null, note: '월 임대료 (생성 시점 MONTHLY_PRICE 고정)']
  STATUS VARCHAR2(20) [not null, default: 'UNPAID', note: 'UNPAID / PAID / CANCELLED']
  DEDUCTED_AMOUNT NUMBER [not null, default: 0, note: '상계로 공제된 누적 금액']
  REMAINING_AMOUNT NUMBER [not null, note: '남은 임대료 (= AMOUNT - DEDUCTED_AMOUNT)']
  PAID_AT TIMESTAMP [note: '결제 확인 시각']
  CREATED_AT TIMESTAMP [not null, default: 'SYSTIMESTAMP']

  indexes {
    (OCCUPIED_RECORD_ID, TARGET_MONTH) [unique, name: 'UQ_RS_RECORD_MONTH', note: '동일 점유 + 동일 월 중복 방지']
  }

  Note: '''
  임대료 정산 테이블.
  점유 생성 시 만기일까지 월별 레코드 일괄 생성 (선불 청구서 패턴).
  입거월은 일할 계산 금액, 이후 월은 정상 월 임대료.
  STATUS CHECK: UNPAID / PAID / CANCELLED
  '''
}

// ============================================================
// DEPOSIT (보증금)
// ============================================================

Table DEPOSIT {
  ID NUMBER [pk, increment, note: 'ISEQ$$_78799']
  BOOK_OWNER_ID NUMBER [unique, not null, ref: - BOOK_OWNER.ID, note: '책소유주당 1건']
  AMOUNT NUMBER [not null, note: '보증금 원금']
  REMAINING_AMOUNT NUMBER [not null, note: '잔여 보증금 (공제 후 남은 금액)']
  STATUS VARCHAR2(20) [not null, default: 'HELD', note: 'HELD / DEPLETED / RETURNED']
  CREATED_AT TIMESTAMP [not null, default: 'SYSTIMESTAMP']

  Note: '''
  보증금 테이블 (BOOK_OWNER 1:1).
  책소유주 단위로 보증금을 통합 관리.
  책장 추가 임대 시 AMOUNT/REMAINING_AMOUNT 누적 적립.
  연체 임대료 공제 시 REMAINING_AMOUNT 차감.
  소진 시 STATUS=DEPLETED → 추가 연체 시 BCOR SUSPENDED.
  STATUS CHECK: HELD / DEPLETED / RETURNED
  '''
}

// ============================================================
// DEPOSIT_RENTAL_OFFSET (보증금-임대료 상계 내역, N:N)
// ============================================================

Table DEPOSIT_RENTAL_OFFSET {
  ID NUMBER [pk, increment, note: 'ISEQ$$_78803']
  DEPOSIT_ID NUMBER [not null, ref: > DEPOSIT.ID, note: '어떤 보증금에서']
  RENTAL_SETTLEMENT_ID NUMBER [not null, ref: > RENTAL_SETTLEMENT.ID, note: '어떤 임대료를']
  OFFSET_AMOUNT NUMBER [not null, note: '이 건에서 공제한 금액']
  CREATED_AT TIMESTAMP [not null, default: 'SYSTIMESTAMP']

  Note: '''
  보증금-임대료 상계 내역 (N:N 관계 추적).
  하나의 보증금이 여러 연체 임대료를 공제할 수 있고,
  하나의 임대료가 여러 차례에 걸쳐 부분 공제될 수 있음.
  매월 1일 05:00 스케줄러가 FIFO 순서로 공제 실행.
  '''
}

// ============================================================
// FK References (복합 FK - COMMON_CODE)
// ============================================================

// BOOK_CASE -> COMMON_CODE (복합 FK: GROUP_CODE_ID + COMMON_CODE_ID)
Ref FK_BC_COMMON_CODE: BOOK_CASE.(GROUP_CODE_ID, COMMON_CODE_ID) > COMMON_CODE.(GROUP_CODE, CODE)

// BOOK -> COMMON_CODE (복합 FK: GROUP_CODE_ID + COMMON_CODE_ID)
Ref FK_BOOK_COMMON_CODE: BOOK.(GROUP_CODE_ID, COMMON_CODE_ID) > COMMON_CODE.(GROUP_CODE, CODE)

// BOOK_SALE_RECORD -> COMMON_CODE (복합 FK: GROUP_CODE_ID + COMMON_CODE_ID)
Ref FK_BSR_COMMON_CODE: BOOK_SALE_RECORD.(GROUP_CODE_ID, COMMON_CODE_ID) > COMMON_CODE.(GROUP_CODE, CODE)

// BOOK_SALE_RECORD -> BOOK (1:1, ID 공유)
Ref FK_BSR_BOOK: BOOK_SALE_RECORD.ID - BOOK.ID




// ============================================================
// BOOK_OWNER_PROFILE (BookOwner 소개글, 1:1)
// ============================================================

Table BOOK_OWNER_PROFILE {
  BOOK_OWNER_ID NUMBER [pk, ref: - BOOK_OWNER.ID, note: '1:1 관계']
  NICKNAME VARCHAR2(50) [unique, not null, note: 'UQ_BOP_NICKNAME']
  FAVORITE_BOOKS VARCHAR2(500) [note: '좋아하는 책들 (자유 텍스트)']
  FAVORITE_AUTHORS VARCHAR2(500) [note: '좋아하는 작가들']
  FAVORITE_GENRES VARCHAR2(500) [note: '좋아하는 장르들']
  CREATED_AT TIMESTAMP [not null, default: 'SYSTIMESTAMP']
  UPDATED_AT TIMESTAMP

  Note: '''
  BookOwner 소개글/프로필.
  BOOK_OWNER와 1:1 (BANK_ACCOUNT와 동일 패턴).
  NICKNAME은 전역 유일.
  '''
}

// ============================================================
// BOOK_OWNER_POST (게시글 - 인스타 피드 스타일)
// ============================================================

Table BOOK_OWNER_POST {
  ID NUMBER [pk, increment, note: '시퀀스명은 테이블 생성 후 조회']
  BOOK_OWNER_ID NUMBER [not null, ref: > BOOK_OWNER.ID]
  BOOK_ID NUMBER [ref: > BOOK.ID, note: 'nullable, 특정 책 홍보 시 연결']
  TITLE VARCHAR2(200) [not null]
  CONTENT VARCHAR2(4000)
  CREATED_AT TIMESTAMP [not null, default: 'SYSTIMESTAMP']
  UPDATED_AT TIMESTAMP
  DELETED_AT TIMESTAMP [note: 'NULL이면 활성 (소프트 삭제)']

  Note: '''
  BookOwner 게시글 (인스타 피드 스타일).
  BOOK_ID로 특정 책을 홍보할 수 있음 (선택사항).
  소프트 삭제: DELETED_AT IS NULL인 행만 활성.
  '''
}

// ============================================================
// POST_COMMENT (댓글 + 1단계 대댓글)
// ============================================================

Table POST_COMMENT {
  ID NUMBER [pk, increment, note: '시퀀스명은 테이블 생성 후 조회']
  POST_ID NUMBER [not null, ref: > BOOK_OWNER_POST.ID]
  USER_ID NUMBER [not null, ref: > USERS.ID, note: '모든 역할 댓글 가능']
  PARENT_ID NUMBER [ref: > POST_COMMENT.ID, note: 'NULL=댓글, NOT NULL=대댓글 (1단계만)']
  CONTENT VARCHAR2(1000) [not null]
  CREATED_AT TIMESTAMP [not null, default: 'SYSTIMESTAMP']
  UPDATED_AT TIMESTAMP
  DELETED_AT TIMESTAMP [note: 'NULL이면 활성 (소프트 삭제)']

  Note: '''
  게시글 댓글 테이블.
  PARENT_ID가 NULL이면 최상위 댓글, NOT NULL이면 대댓글.
  1단계 대댓글만 허용 (PARENT의 PARENT_ID는 반드시 NULL, 앱 레벨 검증).
  모든 인증 사용자(ADMIN, BOOK_OWNER, CUSTOMER, EMPLOYEE) 작성 가능.
  소프트 삭제 지원.
  '''
}

// ============================================================
// FOLLOW (고객 → BookOwner 팔로우)
// ============================================================

Table FOLLOW {
  ID NUMBER [pk, increment, note: '시퀀스명은 테이블 생성 후 조회']
  CUSTOMER_ID NUMBER [not null, ref: > CUSTOMER.ID]
  BOOK_OWNER_ID NUMBER [not null, ref: > BOOK_OWNER.ID]
  CREATED_AT TIMESTAMP [not null, default: 'SYSTIMESTAMP']

  indexes {
    (CUSTOMER_ID, BOOK_OWNER_ID) [unique, name: 'UQ_FOLLOW_PAIR', note: '중복 팔로우 방지']
  }

  Note: '''
  고객의 BookOwner 팔로우 관계.
  UNIQUE(CUSTOMER_ID, BOOK_OWNER_ID)로 중복 방지.
  언팔로우 시 hard DELETE (이력 불필요).
  '''
}
